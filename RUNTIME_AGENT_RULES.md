# RUNTIME_AGENT_RULES.md
**Doctrine: Runtime Agent Behavior for Lupopedia Semantic OS**

---

## 1. Purpose

These rules define how **runtime agents** (primarily PHP-based agents running on application servers or remote nodes) must behave when interacting with:

- the live MySQL database
- atoms and semantic layers
- channel state and actor membership
- doctrine and TOON files

Runtime agents are **execution agents**, not design agents.
They **run the system**, but they do **not** evolve doctrine, schema, or manifests.

---

## 2. Scope

This doctrine applies to:

- All PHP agents running in production or staging environments
- Any remote AI-backed services that read Lupopedia data directly
- Any process that acts on behalf of a user or channel at runtime

It does **not** apply to:

- IDE agents (Cascade, JetBrains, Cursor, etc.)
- Local development tools that modify doctrine, schema, or TOON files

---

## 3. Authority and Boundaries

### 3.1 Read-only domains

Runtime agents may **read** from:

- Doctrine files under `docs/channels/doctrine/`
- Schema doctrine under `docs/channels/schema/`
- TOON files under `docs/toons/*.toon.json`
- Channel manifests and identity blocks
- Atoms and semantic-layer definitions
- Live MySQL tables that are explicitly marked as runtime-readable

Runtime agents must treat all of the above as **read-only**.
They must never:

- edit doctrine
- edit manifests
- edit TOON files
- generate migrations
- alter schema

### 3.2 Write domains

Runtime agents may **write** only to:

- Tables explicitly designated as runtime state (e.g., channel state, dialog logs, semantic paths, message logs, actor presence, etc.)
- Log tables and audit trails intended for runtime use

They must never:

- create or drop tables
- alter columns or indexes
- rename tables
- perform schema migrations

All schema evolution is the responsibility of IDE agents + humans.

---

## 4. Doctrine and TOON Consumption

### 4.1 Doctrine-first behavior

Runtime agents must:

1. **Load doctrine** relevant to their operation (e.g., channel rules, semantic layer rules, emotional rules).
2. **Interpret doctrine as law**, not suggestion.
3. **Refuse to act** if doctrine is missing, inconsistent, or contradictory.

If doctrine and database state conflict, runtime agents must:

- Prefer doctrine
- Log the inconsistency
- Avoid destructive or irreversible actions

### 4.2 TOON as schema reference

Runtime agents may:

- Read `docs/toons/*.toon.json` to understand table structure and semantic meaning.

They must not:

- treat TOON as authoritative over the live DB schema
- attempt to "fix" the database to match TOON
- generate or modify TOON files

TOON is a **reference**, not a target for runtime correction.

---

## 5. Database Interaction Rules

### 5.1 No schema changes

Runtime agents must never execute:

- `CREATE TABLE`
- `DROP TABLE`
- `ALTER TABLE`
- `CREATE INDEX` / `DROP INDEX`
- any DDL statement

All DDL is reserved for migrations generated by IDE agents and executed by humans.

### 5.2 No hard deletes

Runtime agents must:

- never issue `DELETE` that permanently removes rows from heritage or lineage tables
- use soft-delete or Anubis-mediated flows where applicable

If a row must be "removed" from active use, runtime agents must:

- mark it inactive, archived, or redirected
- or invoke the appropriate Anubis/lineage mechanism defined in doctrine

### 5.3 No foreign key assumptions

Runtime agents must:

- not rely on DB-level foreign keys (they do not exist)
- enforce relationship integrity in code, following doctrine and TOON

### 5.4 Timestamp doctrine

Runtime agents must:

- write timestamps only in `UTC` using `YYYYMMDDHHIISS` format
- never use Unix time, `datetime`, or `timestamp` columns for new data
- avoid automatic timezone conversions

---

## 6. Channel, Actor, and Semantic State

### 6.1 Channel state

Runtime agents may:

- read and write channel state tables (e.g., `lupo_channel_state`)
- update actor presence, semantic layers, operational mode, and routing rules
- log emotional or semantic state transitions as defined in doctrine

They must:

- follow channel manifests and identity blocks
- respect per-channel doctrine and constraints
- avoid cross-channel leakage of state unless explicitly allowed

### 6.2 Actor membership

Runtime agents must:

- respect actor membership rules defined in channel manifests and doctrine
- not grant or revoke membership outside of documented flows
- log membership changes with proper timestamps and context

### 6.3 Semantic paths and meaning propagation

Runtime agents may:

- read and write semantic path tables (e.g., `lupo_semantic_paths`)
- propagate meaning according to the Four-Layer Semantic Model

They must:

- avoid destructive overwrites of semantic history
- append or version meaning where possible
- follow lineage and redirect rules when resolving references

---

## 7. Logging, Auditing, and Safety

### 7.1 Logging requirements

Runtime agents must:

- log significant actions (state changes, membership changes, semantic transitions)
- include `UTC` timestamps in `YYYYMMDDHHIISS` format
- include agent identity and channel context

### 7.2 Failure behavior

If a runtime agent:

- encounters missing doctrine
- detects schema mismatch
- sees inconsistent state

...it must:

- fail **safe**, not loud
- avoid destructive actions
- log the issue
- optionally raise a flag for IDE agents or humans

### 7.3 No self-modification

Runtime agents must never:

- modify their own code
- modify doctrine
- modify manifests
- modify TOON files

They are **consumers** of meaning, not authors of it.

---

## 8. Relationship to IDE Agents

- IDE agents (Cascade, JetBrains, Cursor) are responsible for:
  - doctrine editing
  - schema evolution
  - migration generation
  - TOON generation
  - changelog and versioning

- Runtime agents are responsible for:
  - executing meaning
  - maintaining runtime state
  - respecting doctrine and schema
  - logging and traceability

Runtime agents must never attempt to "act like" IDE agents.

---

## 9. Summary

Runtime agents:

- read doctrine, TOON, and manifests
- act on live data within strict boundaries
- never change schema or doctrine
- maintain channel, actor, and semantic state
- log everything with proper timestamps
- fail safe when in doubt

They are the **execution layer** of the Lupopedia Semantic OS, not its authors.
